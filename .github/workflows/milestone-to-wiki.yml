name: Milestone → Wiki (foldered Sprints + Sidebar + All page + Dynamic Home)

on:
  milestone:
    types: [closed, opened, edited]
  workflow_dispatch:
    inputs:
      milestone_number:
        description: "Milestone number to export (optional)"
        required: false

permissions:
  contents: write

env:
  MAX_LATEST: "3"   # set "2" to keep only two latest closed sprints in the sidebar

jobs:
  export-sprint-to-wiki:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout Wiki repo
        uses: actions/checkout@v4
        with:
          repository: ${{ github.repository }}.wiki
          path: wiki
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Build Sprint pages + update sidebar + All page + Home
        uses: actions/github-script@v7
        env:
          WIKI_DIR: wiki
          MAX_LATEST: ${{ env.MAX_LATEST }}
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const fs = require('fs');
            const path = require('path');
            const wikiDir = process.env.WIKI_DIR || 'wiki';
            if (!fs.existsSync(wikiDir)) fs.mkdirSync(wikiDir, { recursive: true });

            const { owner, repo } = context.repo;

            // helpers
            const fmtDate = (s) => s ? new Date(s).toISOString().slice(0,10) : '—';
            const esc = (s) => String(s || '').replace(/\r?\n/g, ' ').trim();
            const mkdirp = (p) => fs.mkdirSync(p, { recursive: true });
            const safePath = (title) => String(title).replace(/[<>:"|?*]/g, '-').replace(/\s+/g, ' ').trim();

            // Which milestone to write full Review for (optional override)
            let milestoneNumber = core.getInput('milestone_number');
            if (!milestoneNumber && context.payload?.milestone?.number) {
              milestoneNumber = String(context.payload.milestone.number);
            }

            // Fetch milestones
            const closedMilestones = await github.paginate(
              github.rest.issues.listMilestones,
              { owner, repo, state: 'closed', sort: 'due_on', direction: 'desc', per_page: 100 }
            );
            const openMilestones = await github.paginate(
              github.rest.issues.listMilestones,
              { owner, repo, state: 'open', sort: 'due_on', direction: 'asc', per_page: 100 }
            );

            if (!milestoneNumber) {
              if (closedMilestones.length > 0) milestoneNumber = String(closedMilestones[0].number);
              else if (openMilestones.length > 0) milestoneNumber = String(openMilestones[0].number);
            }

            async function writeSprintReview(msNumber) {
              const { data: ms } = await github.rest.issues.getMilestone({ owner, repo, milestone_number: msNumber });

              // Gather issues (exclude PRs)
              const allItems = await github.paginate(
                github.rest.issues.listForRepo,
                { owner, repo, state: 'all', milestone: msNumber, per_page: 100 }
              );
              const onlyIssues = allItems.filter(i => !i.pull_request);
              const done = onlyIssues.filter(i => i.state === 'closed');
              const todo = onlyIssues.filter(i => i.state !== 'closed');
              const linkIssue = (x) => `- [#${x.number}](${x.html_url}) ${x.title}`;

              // Sprint name (prefer "Sprint N", else full title)
              const m = (ms.title || '').match(/(Sprint\s+\d+)/i);
              const sprintBase = m ? m[1] : (ms.title || 'Sprint');

              // Foldered location: wiki/Sprints/<Sprint N>/
              const sprintFolder = path.join(wikiDir, 'Sprints', safePath(sprintBase));
              mkdirp(sprintFolder);

              // Review page (full)
              const reviewFile = path.join(sprintFolder, 'Review.md');
              const reviewMd = [
                `# ${sprintBase} Review`,
                '',
                `**Milestone:** [${esc(ms.title)}](${ms.html_url})`,
                `**State:** ${ms.state}`,
                `**Due:** ${fmtDate(ms.due_on)}  |  **Closed:** ${fmtDate(ms.closed_at)}`,
                `**Issues:** ${onlyIssues.length} total — ${done.length} closed / ${todo.length} open`,
                '',
                '---',
                '## Outcomes',
                `- All issues: [${esc(ms.title)}](${ms.html_url})`,
                '',
                '### Completed',
                done.length ? done.map(linkIssue).join('\n') : '_None_',
                '',
                '### Not Completed',
                todo.length ? todo.map(linkIssue).join('\n') : '_None_',
                '',
                '---',
                '## Review Notes',
                '- Highlights: _fill in_',
                '- Demos: _links/screenshots_',
                '',
                '## Retrospective (optional)',
                `- See [[${sprintBase} Retro|Sprints/${safePath(sprintBase)}/Retro]].`,
                '',
                '---',
                '## Links',
                `- Milestone: ${ms.html_url}`,
                `- Repository: https://github.com/${owner}/${repo}`,
                ''
              ].join('\n');
              fs.writeFileSync(reviewFile, reviewMd, 'utf8');

              // Retro page scaffold (keep existing if present)
              const retroFile = path.join(sprintFolder, 'Retro.md');
              if (!fs.existsSync(retroFile)) {
                fs.writeFileSync(retroFile, [
                  `# ${sprintBase} Retro`,
                  '',
                  '## What went well',
                  '- ',
                  '',
                  '## What could be improved',
                  '- ',
                  '',
                  '## Action items',
                  '- ',
                  ''
                ].join('\n'), 'utf8');
              }
            }

            // Write selected sprint's Review as full content
            if (milestoneNumber) {
              try { await writeSprintReview(parseInt(milestoneNumber, 10)); }
              catch (e) { core.warning(`Could not write selected milestone #${milestoneNumber}: ${e.message}`); }
            }

            // Ensure Practices and Templates exist
            const practicesFile = path.join(wikiDir, 'Practices', 'How-we-work.md');
            mkdirp(path.dirname(practicesFile));
            if (!fs.existsSync(practicesFile)) {
              fs.writeFileSync(practicesFile,
                '# Practices – How we work\n\n- Definition of Done\n- Branching strategy\n- Estimation scale\n', 'utf8');
            }
            const templatesFile = path.join(wikiDir, 'Templates', 'README.md');
            mkdirp(path.dirname(templatesFile));
            if (!fs.existsSync(templatesFile)) {
              fs.writeFileSync(templatesFile,
                '# Templates\n\n- Sprint Review template\n- Sprint Retro template\n', 'utf8');
            }

            // Build/refresh "All Sprints" page listing all milestones
            const allMilestones = [
              ...closedMilestones.map(m => ({ ...m, _stateOrder: 0 })), // closed first (we'll render in desc due)
              ...openMilestones.map(m => ({ ...m, _stateOrder: 1 }))    // then open (asc due)
            ];

            const rows = allMilestones.map(m => {
              const sm = (m.title || '').match(/(Sprint\s+\d+)/i);
              const base = sm ? sm[1] : (m.title || 'Sprint');
              const basePath = `Sprints/${safePath(base)}`;
              const sprintFolder = path.join(wikiDir, basePath);
              mkdirp(sprintFolder);

              const reviewPath = path.join(sprintFolder, 'Review.md');
              if (!fs.existsSync(reviewPath)) {
                fs.writeFileSync(reviewPath, `# ${base} Review\n\n_(coming soon)_\n`, 'utf8');
              }
              const retroPath = path.join(sprintFolder, 'Retro.md');
              if (!fs.existsSync(retroPath)) {
                fs.writeFileSync(retroPath, `# ${base} Retro\n\n_(coming soon)_\n`, 'utf8');
              }

              const due = fmtDate(m.due_on);
              const closed = fmtDate(m.closed_at);
              const statePretty = m.state === 'closed' ? 'Closed' : 'Open';
              const reviewLink = `[[Review|${basePath}/Review]]`;
              const retroLink  = `[[Retro|${basePath}/Retro]]`;

              return {
                isClosed: m.state === 'closed',
                dueOn: m.due_on || '',
                md: `| [[${base}|${basePath}]] | ${statePretty} | ${due} | ${closed} | ${reviewLink} · ${retroLink} |`
              };
            });

            const closedRows = rows.filter(r => r.isClosed)
              .sort((a,b) => (a.dueOn < b.dueOn ? 1 : -1));
            const openRows   = rows.filter(r => !r.isClosed)
              .sort((a,b) => (a.dueOn < b.dueOn ? -1 : 1));

            const allMd = [
              '# All Sprints',
              '',
              'A consolidated index of all sprints. Columns show current state, due/closed dates, and quick links.',
              '',
              '## Closed',
              '',
              '| Sprint | State | Due | Closed | Links |',
              '|---|---|---|---|---|',
              closedRows.length ? closedRows.map(r => r.md).join('\n') : '| _None_ |  |  |  |  |',
              '',
              '## Open',
              '',
              '| Sprint | State | Due | Closed | Links |',
              '|---|---|---|---|---|',
              openRows.length ? openRows.map(r => r.md).join('\n') : '| _None_ |  |  |  |  |',
              ''
            ].join('\n');

            const allSprintsFile = path.join(wikiDir, 'Sprints', 'All.md');
            mkdirp(path.dirname(allSprintsFile));
            fs.writeFileSync(allSprintsFile, allMd, 'utf8');

            // Sidebar with latest N closed sprints
            const maxLatest = parseInt(process.env.MAX_LATEST || '3', 10);
            const latest = closedMilestones.slice(0, maxLatest);

            const sidebarSprintBlocks = latest.map(m => {
              const sm = (m.title || '').match(/(Sprint\s+\d+)/i);
              const base = sm ? m[1] : (m.title || 'Sprint');
              const basePath = `Sprints/${safePath(base)}`;
              const reviewLink = `[[${base} Review|${basePath}/Review]]`;
              const retroLink  = `[[${base} Retro|${basePath}/Retro]]`;
              return [
                `- ${base}`,
                `  - ${reviewLink}`,
                `  - ${retroLink}`
              ].join('\n');
            }).join('\n');

            const sidebar = [
              '[[Home]]',
              '',
              '## Sprints',
              sidebarSprintBlocks || '_No closed sprints yet_',
              '',
              '---',
              '[[All Sprints|Sprints/All]]',
              '[[Practices - How we work|Practices/How-we-work]]',
              '[[Templates|Templates/README]]',
              ''
            ].join('\n');
            fs.writeFileSync(path.join(wikiDir, '_Sidebar.md'), sidebar, 'utf8');

            // ===== Dynamic Home.md =====
            const currentOpen = openMilestones[0] || null;       // soonest-due open
            const latestClosed = closedMilestones[0] || null;     // most recently due closed

            function sprintName(ms) {
              const m = (ms?.title || '').match(/(Sprint\s+\d+)/i);
              return m ? m[1] : (ms?.title || 'Sprint');
            }
            function sprintLinks(ms) {
              const base = sprintName(ms);
              const basePath = `Sprints/${safePath(base)}`;
              return `[[Review|${basePath}/Review]] · [[Retro|${basePath}/Retro]]`;
            }

            const sections = [
              '# Testing Project Wiki',
              '',
              'Welcome! This wiki tracks our Agile cadence: sprint reviews, retrospectives, and ways of working.',
              ''];

            if (currentOpen) {
              const name = sprintName(currentOpen);
              sections.push(
                '## Current Sprint',
                `**${esc(name)}**`,
                `Due: ${fmtDate(currentOpen.due_on)}`,
                sprintLinks(currentOpen),
                ''
              );
            }

            if (latestClosed) {
              const name = sprintName(latestClosed);
              sections.push(
                '## Latest Sprint',
                `**${esc(name)}**`,
                `Closed: ${fmtDate(latestClosed.closed_at)}`,
                sprintLinks(latestClosed),
                ''
              );
            }

            sections.push(
              '---',
              '### Quick Links',
              '- [[All Sprints|Sprints/All]]',
              '- [[Practices - How we work|Practices/How-we-work]]',
              '- [[Templates|Templates/README]]',
              '---'
              '## What this is',
              '- Public record of what we planned, shipped, and learned.',
              '- Great for hiring managers: a transparent view of process and outcomes.',
              ''
            );

            fs.writeFileSync(path.join(wikiDir, 'Home.md'), sections.join('\n'), 'utf8');

      - name: Commit & Push wiki changes
        run: |
          cd wiki
          git config user.name  "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
          git add -A
          git commit -m "docs(wiki): update sprint pages, sidebar, All, and dynamic Home" || echo "No changes to commit."
          git push
