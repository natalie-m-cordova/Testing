name: Issue Ops (Project • Owner • Labels • Sprint→Field/Milestone)

on:
  issues:
    types: [opened, edited, labeled, reopened]
  workflow_dispatch:
    inputs:
      number:
        description: "Issue number to reprocess (optional)"
        required: false
        type: number

env:
  PROJECT_BOARD_NAME: "Testing Project Board"
  PROJECT_SPRINT_FIELD_NAME: "Sprints"
  DEFAULT_ASSIGNEES: "NMRCDova"
  TYPE_LABEL_MAP_JSON: >-
    {
      "epic": "type: Epic",
      "bug": "type: Bug",
      "enhancement": "type: Enhancement",
      "documentation": "type: Documentation",
      "duplicate": "type: Duplicate"
    }

permissions:
  contents: read
  issues: write

concurrency:
  group: ${{ github.workflow }}-${{ github.event.issue.number || inputs.number || github.run_id }}
  cancel-in-progress: false

jobs:
  prepare:
    name: Prepare context
    runs-on: ubuntu-latest
    outputs:
      issue_number: ${{ steps.ctx.outputs.issue_number }}
      issue_node_id: ${{ steps.ctx.outputs.issue_node_id }}
      labels_json: ${{ steps.ctx.outputs.labels_json }}
      sprint_label: ${{ steps.ctx.outputs.sprint_label }}
      sprint_slug: ${{ steps.ctx.outputs.sprint_slug }}
    steps:
      - name: Derive context
        id: ctx
        uses: actions/github-script@v7
        env:
          DISPATCH_ISSUE_NUMBER: ${{ inputs.number }}
        with:
          script: |
            const owner = context.repo.owner;
            const repo  = context.repo.repo;

            const inputNumberRaw =
              (process.env.DISPATCH_ISSUE_NUMBER || (context.payload.inputs && context.payload.inputs.number) || '').trim();

            let issue = null;
            if (inputNumberRaw) {
              const n = Number(inputNumberRaw);
              if (Number.isFinite(n) && n > 0) {
                try {
                  issue = (await github.rest.issues.get({ owner, repo, issue_number: n })).data;
                } catch (e) {
                  core.setFailed(`Could not load issue #${n}: ${e.message}`);
                  core.setOutput('issue_number', '');
                  core.setOutput('issue_node_id', '');
                  core.setOutput('labels_json', '[]');
                  core.setOutput('sprint_label', '');
                  core.setOutput('sprint_slug', '');
                  return;
                }
              }
            } else if (context.payload && context.payload.issue) {
              issue = context.payload.issue;
            }

            if (!issue) {
              core.setFailed("No issue context found (on workflow_dispatch, pass 'number').");
              core.setOutput('issue_number', '');
              core.setOutput('issue_node_id', '');
              core.setOutput('labels_json', '[]');
              core.setOutput('sprint_label', '');
              core.setOutput('sprint_slug', '');
              return;
            }

            const labels = (issue.labels || []).map(l => typeof l === 'string' ? l : (l.name || '')).filter(Boolean);

            // Accept: "sprint12", "sprint 12", "sprint#12"
            const sprintLabel = labels.find(l => /^sprint\s*[-#]?\s*\d+$/i.test(l)) || '';
            let sprintNum = '';
            if (sprintLabel) {
              const m = sprintLabel.match(/sprint\s*[-#]?\s*(\d+)/i) || sprintLabel.match(/sprint(\d+)/i);
              sprintNum = m ? m[1] : '';
            }
            const sprintDisplay = sprintNum ? `Sprint ${sprintNum}` : '';   // e.g., "Sprint 12"

            const data = await github.graphql(
              `query($owner:String!,$repo:String!,$number:Int!){
                 repository(owner:$owner, name:$repo){ issue(number:$number){ id number } }
               }`,
              { owner, repo, number: issue.number }
            );
            const nodeId = data?.repository?.issue?.id || '';

            core.setOutput('issue_number', String(issue.number));
            core.setOutput('issue_node_id', nodeId);
            core.setOutput('labels_json', JSON.stringify(labels));
            core.setOutput('sprint_label', sprintLabel);      // original label text
            core.setOutput('sprint_slug', sprintDisplay);     // normalized "Sprint N"

      - name: Log context
        if: ${{ steps.ctx.outputs.issue_number != '' }}
        run: |
          echo "issue_number=${{ steps.ctx.outputs.issue_number }}"
          echo "sprint_label=${{ steps.ctx.outputs.sprint_label }}"
          echo "labels=${{ steps.ctx.outputs.labels_json }}"

  assign_and_normalize:
    name: Assign owner & set Issue Type (keep original labels)
    runs-on: ubuntu-latest
    needs: [prepare]
    steps:
      - name: Assign default owners (if configured)
        if: ${{ env.DEFAULT_ASSIGNEES != '' }}
        uses: actions/github-script@v7
        with:
          script: |
            try {
              const list = (process.env.DEFAULT_ASSIGNEES || '').split(',').map(s=>s.trim()).filter(Boolean);
              if (!list.length) { core.info('No default assignees configured.'); return; }
              await github.rest.issues.addAssignees({
                ...context.repo,
                issue_number: Number("${{ needs.prepare.outputs.issue_number }}"),
                assignees: list
              });
              core.info(`Assigned: ${list.join(', ')}`);
            } catch (e) {
              core.warning(`Could not assign default owners: ${e.message}`);
            }

      - name: Map label -> Issue Type name
        id: map
        uses: actions/github-script@v7
        env:
          LABELS_JSON: ${{ needs.prepare.outputs.labels_json }}
          TYPE_LABEL_MAP_JSON: ${{ env.TYPE_LABEL_MAP_JSON }}
        with:
          result-encoding: string
          script: |
            const labels = JSON.parse(process.env.LABELS_JSON || '[]').map(l => String(l||'').toLowerCase());
            const map = JSON.parse(process.env.TYPE_LABEL_MAP_JSON || '{}');
            const order = ['epic', 'bug','enhancement','documentation','duplicate']; // old workflow precedence
            for (const k of order) {
              if (labels.includes(k) && map[k]) {
                return String(map[k]).replace(/^type:\s*/i,'').trim();
              }
            }
            return '';

      - name: Note (no matching type from labels)
        if: ${{ steps.map.outputs.result == '' }}
        run: echo "No mapped Issue Type from labels. Skipping type update."

      - name: Check PAT availability
        id: pat
        env:
          PAT: ${{ secrets.ORG_GRAPHQL_TOKEN }}
        run: |
          if [ -n "${PAT}" ]; then echo "has=true" >> "$GITHUB_OUTPUT"; else echo "has=false" >> "$GITHUB_OUTPUT"; fi


      - name: Inspect owner type (User vs Organization)
        id: owner
        if: ${{ steps.map.outputs.result != '' && steps.pat.outputs.has == 'true' }}
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.ORG_GRAPHQL_TOKEN }}
          result-encoding: string
          script: |
            const { owner, repo } = context.repo;
            const q = `
              query($owner:String!, $repo:String!) {
                repository(owner:$owner, name:$repo) { owner { __typename } }
              }`;
            const d = await github.graphql(q, { owner, repo });
            return d.repository.owner.__typename; // "Organization" or "User"

      - name: Note (Issue Types require org + PAT)
        if: ${{ steps.map.outputs.result != '' && (steps.pat.outputs.has != 'true' || steps.owner.outputs.result != 'Organization') }}
        run: echo "Skipping Issue Type update (PAT missing or owner is not an Organization)."

      - name: Set Issue Type (GraphQL via PAT)
        if: ${{ steps.map.outputs.result != '' && steps.pat.outputs.has == 'true' && steps.owner.outputs.result == 'Organization' }}
        uses: actions/github-script@v7
        env:
          TYPE_NAME: ${{ steps.map.outputs.result }}
          ISSUE_NUMBER: ${{ needs.prepare.outputs.issue_number }}
        with:
          github-token: ${{ secrets.ORG_GRAPHQL_TOKEN }}
          script: |
            const { owner, repo } = context.repo;
            const typeName = process.env.TYPE_NAME;
            const number = parseInt(process.env.ISSUE_NUMBER, 10);

            // Get Issue node id
            const q1 = `
              query($owner:String!, $repo:String!, $number:Int!) {
                repository(owner:$owner, name:$repo) {
                  issue(number:$number) { id }
                  owner {
                    __typename
                    ... on Organization {
                      issueTypes(first:100) { nodes { id name } }
                    }
                  }
                }
              }`;
            const d1 = await github.graphql(q1, { owner, repo, number });
            const issueId = d1.repository.issue.id;

            const org = d1.repository.owner;
            if (!org || org.__typename !== 'Organization' || !org.issueTypes) {
              throw new Error("Issue Types not enabled or accessible for this org (check PAT scopes + SSO).");
            }
            const match = org.issueTypes.nodes.find(t => t.name.toLowerCase() === typeName.toLowerCase());
            if (!match) throw new Error(`Issue Type "${typeName}" not found. Create it in org settings or adjust mapping.`);

            const mut = `
              mutation($issueId:ID!, $issueTypeId:ID!) {
                updateIssue(input: {id:$issueId, issueTypeId:$issueTypeId}) {
                  issue { id number }
                }
              }`;
            await github.graphql(mut, { issueId, issueTypeId: match.id });
            core.info(`Issue #${number}: type set to "${typeName}".`);

  project_add:
    name: Add to Project board
    runs-on: ubuntu-latest
    needs: [prepare]
    outputs:
      item_id: ${{ steps.add_item.outputs.item_id }}
    steps:
      - name: Skip (no project board name set)
        if: ${{ env.PROJECT_BOARD_NAME == '' }}
        run: echo "PROJECT_BOARD_NAME not set; skipping project add."
        
      - name: Check PAT availability
        id: pat
        env:
          PAT: ${{ secrets.ORG_GRAPHQL_TOKEN }}
        run: |
          if [ -n "${PAT}" ]; then echo "has=true" >> "$GITHUB_OUTPUT"; else echo "has=false" >> "$GITHUB_OUTPUT"; fi

      - name: Add issue to Project (Projects v2)
        id: add_item
        if: ${{ env.PROJECT_BOARD_NAME != '' && steps.pat.outputs.has == 'true' }}
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.ORG_GRAPHQL_TOKEN }}
          script: |
            const owner = context.repo.owner;
            const projectTitle = process.env.PROJECT_BOARD_NAME;
            const issueNodeId = "${{ needs.prepare.outputs.issue_node_id }}";
            if (!issueNodeId) { core.setFailed("Missing issue node id."); return; }

            async function findProjectId() {
              try {
                const qOrg = await github.graphql(`
                  query($login:String!, $q:String!) {
                    organization(login:$login) { projectsV2(first: 20, query: $q) { nodes { id title } } }
                  }`, { login: owner, q: projectTitle });
                const p = qOrg?.organization?.projectsV2?.nodes?.find(n => n.title === projectTitle);
                if (p) return p.id;
              } catch {}
              const qUser = await github.graphql(`
                query($login:String!, $q:String!) {
                  user(login:$login) { projectsV2(first: 20, query: $q) { nodes { id title } } }
                }`, { login: owner, q: projectTitle });
              return qUser?.user?.projectsV2?.nodes?.find(n => n.title === projectTitle)?.id || null;
            }

            const projectId = await findProjectId();
            if (!projectId) { core.warning(`Project board "${projectTitle}" not found under ${owner}. Skipping.`); return; }

            const added = await github.graphql(`
              mutation($projectId:ID!, $contentId:ID!) {
                addProjectV2ItemById(input:{ projectId:$projectId, contentId:$contentId }) {
                  item { id }
                }
              }`, { projectId, contentId: issueNodeId });
            const itemId = added?.addProjectV2ItemById?.item?.id || "";
            core.setOutput('item_id', itemId);
            core.info(`Added to project "${projectTitle}" (itemId=${itemId}).`);
      - name: Note (PAT missing)
        if: ${{ env.PROJECT_BOARD_NAME != '' && steps.pat.outputs.has != 'true' }}
        run: echo "ORG_GRAPHQL_TOKEN not set; cannot modify org Projects v2. Skipping project add."

  sprint_to_project_field:
    name: Sprint → Project field
    runs-on: ubuntu-latest
    needs: [prepare, project_add]
    steps:
      - name: Skip (no sprint slug or field name)
        if: ${{ needs.prepare.outputs.sprint_slug == '' || env.PROJECT_SPRINT_FIELD_NAME == '' }}
        run: echo "No sprint slug or field name; skipping project field update."

      - name: Check PAT availability
        id: pat
        env:
          PAT: ${{ secrets.ORG_GRAPHQL_TOKEN }}
        run: |
          if [ -n "${PAT}" ]; then echo "has=true" >> "$GITHUB_OUTPUT"; else echo "has=false" >> "$GITHUB_OUTPUT"; fi

      - name: Update Project field (uses PAT)
        if: ${{ needs.prepare.outputs.sprint_slug != '' && env.PROJECT_SPRINT_FIELD_NAME != '' && steps.pat.outputs.has == 'true' }}
        uses: actions/github-script@v7
        env:
          ITEM_ID_FROM_ADD: ${{ needs.project_add.outputs.item_id }}
        with:
          github-token: ${{ secrets.ORG_GRAPHQL_TOKEN }}
          script: |
            const owner = context.repo.owner;
            const projectTitle = process.env.PROJECT_BOARD_NAME;
            const fieldName = process.env.PROJECT_SPRINT_FIELD_NAME;
            const issueNodeId = "${{ needs.prepare.outputs.issue_node_id }}";
            const sprintDisplay = "${{ needs.prepare.outputs.sprint_slug }}";

            const norm = s => String(s||'').toLowerCase().replace(/[^a-z0-9]/g,'');
            const targetKey = norm(sprintDisplay);

            async function findProjectId() {
              try {
                const qOrg = await github.graphql(`
                  query($login:String!, $q:String!) {
                    organization(login:$login) { projectsV2(first: 20, query: $q) { nodes { id title } } }
                  }`, { login: owner, q: projectTitle });
                const p = qOrg?.organization?.projectsV2?.nodes?.find(n => n.title === projectTitle);
                if (p) return p.id;
              } catch {}
              const qUser = await github.graphql(`
                query($login:String!,$q:String!) {
                  user(login:$login) { projectsV2(first: 20, query: $q) { nodes { id title } } }
                }`, { login: owner, q: projectTitle });
              return qUser?.user?.projectsV2?.nodes?.find(n => n.title === projectTitle)?.id || null;
            }

            const projectId = await findProjectId();
            if (!projectId) { core.warning(`Project "${projectTitle}" not found.`); return; }

            // Prefer the item id from add step; otherwise retry-search
            let itemId = process.env.ITEM_ID_FROM_ADD || '';
            if (!itemId) {
              for (let attempt = 1; attempt <= 5 && !itemId; attempt++) {
                const items = await github.graphql(`
                  query($projectId:ID!, $after:String) {
                    node(id:$projectId) { ... on ProjectV2 {
                      items(first: 100, after:$after) {
                        nodes { id content { ... on Issue { id number } } }
                        pageInfo { hasNextPage endCursor }
                      }
                    }}`, { projectId });

                let page = items?.node?.items;
                while (page) {
                  const hit = page.nodes?.find(n => n?.content?.id === issueNodeId);
                  if (hit?.id) { itemId = hit.id; break; }
                  if (page.pageInfo?.hasNextPage) {
                    const more = await github.graphql(`
                      query($projectId:ID!, $after:String) {
                        node(id:$projectId) { ... on ProjectV2 {
                          items(first: 100, after:$after) {
                            nodes { id content { ... on Issue { id number } } }
                            pageInfo { hasNextPage endCursor }
                          }
                        }}`, { projectId, after: page.pageInfo.endCursor });
                    page = more?.node?.items;
                  } else break;
                }

                if (!itemId) {
                  core.info(`Item not visible yet (attempt ${attempt}/5). Waiting 2s...`);
                  await new Promise(r => setTimeout(r, 2000));
                }
              }
            }
            if (!itemId) { core.warning('Project item not found for this issue.'); return; }

            // Fetch fields and locate the Sprint field
            const fields = await github.graphql(`
              query($projectId:ID!) {
                node(id:$projectId) { ... on ProjectV2 {
                  fields(first: 50) {
                    nodes {
                      ... on ProjectV2FieldCommon { id name dataType }
                      ... on ProjectV2SingleSelectField { id name dataType options { id name } }
                      ... on ProjectV2IterationField { id name dataType configuration { iterations { id title } } }
                    }
                  }
                }}
              }`, { projectId }
            );
            const f = fields?.node?.fields?.nodes?.find(x => (x?.name||"") === fieldName);
            if (!f?.id) { core.warning(`Field "${fieldName}" not found.`); return; }

            let value = null;
            if (f.dataType === 'TEXT') {
              value = { text: sprintDisplay }; // "Sprint N"
            } else if (f.dataType === 'SINGLE_SELECT') {
              const opt = (f.options || []).find(o => {
                const k = norm(o.name);
                return k === targetKey || k.startsWith(targetKey); // match "Sprint 12" or "Sprint 12 – …"
              });
              if (!opt) { core.warning(`Single-select option for "${sprintDisplay}" not found.`); return; }
              value = { singleSelectOptionId: opt.id };
            } else if (f.dataType === 'ITERATION') {
              const iter = f.configuration?.iterations?.find(i => {
                const k = norm(i.title);
                return k === targetKey || k.startsWith(targetKey);
              });
              if (!iter) { core.warning(`Iteration "${sprintDisplay}" not found.`); return; }
              value = { iterationId: iter.id };
            } else {
              core.warning(`Unsupported field dataType: ${f.dataType}`);
              return;
            }

            await github.graphql(`
              mutation($projectId:ID!,$itemId:ID!,$fieldId:ID!,$value:ProjectV2FieldValue!) {
                updateProjectV2ItemFieldValue(input:{
                  projectId:$projectId, itemId:$itemId, fieldId:$fieldId, value:$value
                }) { projectV2Item { id } }
              }`, { projectId, itemId, fieldId: f.id, value }
            );
            core.info(`Updated project field "${fieldName}" to "${sprintDisplay}".`);

      - name: Note (PAT missing)
        if: ${{ needs.prepare.outputs.sprint_slug != '' && env.PROJECT_SPRINT_FIELD_NAME != '' && steps.pat.outputs.has != 'true' }}
        run: echo "ORG_GRAPHQL_TOKEN not set; cannot update org Projects v2 field. Skipping."

  sprint_to_milestone:
    name: Sprint → Milestone
    runs-on: ubuntu-latest
    needs: [prepare]
    if: ${{ needs.prepare.outputs.sprint_slug != '' }}
    steps:
      - name: "Ensure milestone exists and assign (robust match: \"Sprint # - …\")"
        uses: actions/github-script@v7
        env:
          SPRINT_DISPLAY: ${{ needs.prepare.outputs.sprint_slug }}
          ISSUE_NUMBER: ${{ needs.prepare.outputs.issue_number }}
        with:
          script: |
            const sprintDisplay = process.env.SPRINT_DISPLAY || '';   // "Sprint 12"
            const issueNumber   = parseInt(process.env.ISSUE_NUMBER, 10);

            // Extract the sprint number (12)
            const num = (sprintDisplay.match(/(\d+)/) || [])[1];
            if (!num) {
              core.warning(`Could not extract sprint number from "${sprintDisplay}".`);
              return;
            }

            // Build a tolerant matcher:
            // ^Sprint\s*#?\s*12(\b|space|dash)   → matches "Sprint 12", "Sprint #12", "Sprint 12 - Foo"
            const re = new RegExp(`^\\s*sprint\\s*#?\\s*${num}(\\b|\\s|[-–—])`, 'i');

            // Search ALL milestones so we can match closed ones too
            const all = await github.paginate(
              github.rest.issues.listMilestones,
              { ...context.repo, state: 'all', per_page: 100 }
            );

            const matches = all.filter(m => re.test(m.title || ''));

            // Prefer OPEN > then best CLOSED
            let chosen = null;
            const open = matches.filter(m => m.state !== 'closed');
            if (open.length) {
              // Among open, prefer earliest due date (if present)
              open.sort((a,b) => (a.due_on || '9999').localeCompare(b.due_on || '9999'));
              chosen = open[0];
            } else if (matches.length) {
              // Among closed, prefer most recently closed
              matches
                .filter(m => m.state === 'closed')
                .sort((a,b) => (b.closed_at || '').localeCompare(a.closed_at || ''));
              chosen = matches[0];
            }

            // If none matched, create a minimal "Sprint N"
            if (!chosen) {
              const { data: created } = await github.rest.issues.createMilestone({
                ...context.repo,
                title: sprintDisplay
              });
              chosen = created;
              core.info(`Created milestone: ${created.title}`);
            } else {
              core.info(`Matched milestone: ${chosen.title} (state=${chosen.state})`);
            }

            // Assign the milestone
            await github.rest.issues.update({
              ...context.repo,
              issue_number: issueNumber,
              milestone: chosen.number
            });
            core.info(`Assigned milestone "${chosen.title}" to issue #${issueNumber}.`);
