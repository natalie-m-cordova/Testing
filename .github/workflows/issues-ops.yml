name: Issue Ops (Project • Owner • Labels • Sprint→Field/Milestone)

on:
  issues:
    types: [opened, edited, labeled, reopened]
  workflow_dispatch:
    inputs:
      number:
        description: "Issue number to reprocess (optional)"
        required: false
        type: number

env:
  PROJECT_BOARD_NAME: "Testing Project Board"
  PROJECT_SPRINT_FIELD_NAME: "Sprints"
  PROJECT_PRIORITY_FIELD_NAME: "Priority"
  PROJECT_TARGET_DATE_FIELD_NAME: "Target Date"
  DEFAULT_ASSIGNEES: "NMRCDova"
  DEFAULT_PRIORITY: "Low"
  TARGET_DATE_OFFSET_DAYS: "7"
  TYPE_LABEL_MAP_JSON: >-
    {
      "epic": "type: Epic",
      "bug": "type: Bug",
      "enhancement": "type: Enhancement",
      "documentation": "type: Documentation",
      "duplicate": "type: Duplicate"
    }

permissions:
  contents: read
  issues: write

concurrency:
  group: ${{ github.workflow }}-${{ github.event.issue.number || inputs.number || github.run_id }}
  cancel-in-progress: false

jobs:
  prepare:
    name: Prepare context
    runs-on: ubuntu-latest
    outputs:
      issue_number: ${{ steps.ctx.outputs.issue_number }}
      issue_node_id: ${{ steps.ctx.outputs.issue_node_id }}
      labels_json: ${{ steps.ctx.outputs.labels_json }}
      sprint_label: ${{ steps.ctx.outputs.sprint_label }}
      sprint_slug: ${{ steps.ctx.outputs.sprint_slug }}
    steps:
      - name: Derive context
        id: ctx
        uses: actions/github-script@v7
        env:
          DISPATCH_ISSUE_NUMBER: ${{ inputs.number }}
        with:
          script: |
            const owner = context.repo.owner;
            const repo  = context.repo.repo;

            const inputNumberRaw =
              (process.env.DISPATCH_ISSUE_NUMBER || (context.payload.inputs && context.payload.inputs.number) || '').trim();

            let issue = null;
            if (inputNumberRaw) {
              const n = Number(inputNumberRaw);
              if (Number.isFinite(n) && n > 0) {
                try {
                  issue = (await github.rest.issues.get({ owner, repo, issue_number: n })).data;
                } catch (e) {
                  core.setFailed(`Could not load issue #${n}: ${e.message}`);
                  core.setOutput('issue_number', '');
                  core.setOutput('issue_node_id', '');
                  core.setOutput('labels_json', '[]');
                  core.setOutput('sprint_label', '');
                  core.setOutput('sprint_slug', '');
                  return;
                }
              }
            } else if (context.payload && context.payload.issue) {
              issue = context.payload.issue;
            }

            if (!issue) {
              core.setFailed("No issue context found (on workflow_dispatch, pass 'number').");
              core.setOutput('issue_number', '');
              core.setOutput('issue_node_id', '');
              core.setOutput('labels_json', '[]');
              core.setOutput('sprint_label', '');
              core.setOutput('sprint_slug', '');
              return;
            }

            const labels = (issue.labels || []).map(l => typeof l === 'string' ? l : (l.name || '')).filter(Boolean);

            // Accept: "sprint12", "sprint 12", "sprint#12"
            const sprintLabel = labels.find(l => /^sprint\s*[-#]?\s*\d+$/i.test(l)) || '';
            let sprintNum = '';
            if (sprintLabel) {
              const m = sprintLabel.match(/sprint\s*[-#]?\s*(\d+)/i) || sprintLabel.match(/sprint(\d+)/i);
              sprintNum = m ? m[1] : '';
            }
            const sprintDisplay = sprintNum ? `Sprint ${sprintNum}` : '';   // e.g., "Sprint 12"

            const data = await github.graphql(
              `query($owner:String!,$repo:String!,$number:Int!){
                 repository(owner:$owner, name:$repo){ issue(number:$number){ id number } }
               }`,
              { owner, repo, number: issue.number }
            );
            const nodeId = data?.repository?.issue?.id || '';

            core.setOutput('issue_number', String(issue.number));
            core.setOutput('issue_node_id', nodeId);
            core.setOutput('labels_json', JSON.stringify(labels));
            core.setOutput('sprint_label', sprintLabel);      // original label text
            core.setOutput('sprint_slug', sprintDisplay);     // normalized "Sprint N"

      - name: Log context
        if: ${{ steps.ctx.outputs.issue_number != '' }}
        run: |
          echo "issue_number=${{ steps.ctx.outputs.issue_number }}"
          echo "sprint_label=${{ steps.ctx.outputs.sprint_label }}"
          echo "labels=${{ steps.ctx.outputs.labels_json }}"

  assign_and_normalize:
    name: Assign owner & set Issue Type (keep original labels)
    runs-on: ubuntu-latest
    needs: [prepare]
    steps:
      - name: Assign default owners (if configured)
        if: ${{ env.DEFAULT_ASSIGNEES != '' }}
        uses: actions/github-script@v7
        with:
          script: |
            try {
              const list = (process.env.DEFAULT_ASSIGNEES || '').split(',').map(s=>s.trim()).filter(Boolean);
              if (!list.length) { core.info('No default assignees configured.'); return; }
              await github.rest.issues.addAssignees({
                ...context.repo,
                issue_number: Number("${{ needs.prepare.outputs.issue_number }}"),
                assignees: list
              });
              core.info(`Assigned: ${list.join(', ')}`);
            } catch (e) {
              core.warning(`Could not assign default owners: ${e.message}`);
            }

      - name: Map label -> Issue Type name
        id: map
        uses: actions/github-script@v7
        env:
          LABELS_JSON: ${{ needs.prepare.outputs.labels_json }}
          TYPE_LABEL_MAP_JSON: ${{ env.TYPE_LABEL_MAP_JSON }}
        with:
          result-encoding: string
          script: |
            const labels = JSON.parse(process.env.LABELS_JSON || '[]').map(l => String(l||'').toLowerCase());
            const map = JSON.parse(process.env.TYPE_LABEL_MAP_JSON || '{}');
            const order = ['epic', 'bug','enhancement','documentation','duplicate']; // old workflow precedence
            for (const k of order) {
              if (labels.includes(k) && map[k]) {
                return String(map[k]).replace(/^type:\s*/i,'').trim();
              }
            }
            return '';

      - name: Note (no matching type from labels)
        if: ${{ steps.map.outputs.result == '' }}
        run: echo "No mapped Issue Type from labels. Skipping type update."

      - name: Check PAT availability
        id: pat
        env:
          PAT: ${{ secrets.ORG_GRAPHQL_TOKEN }}
        run: |
          if [ -n "${PAT}" ]; then echo "has=true" >> "$GITHUB_OUTPUT"; else echo "has=false" >> "$GITHUB_OUTPUT"; fi


      - name: Inspect owner type (User vs Organization)
        id: owner
        if: ${{ steps.map.outputs.result != '' && steps.pat.outputs.has == 'true' }}
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.ORG_GRAPHQL_TOKEN }}
          result-encoding: string
          script: |
            const { owner, repo } = context.repo;
            const q = `
              query($owner:String!, $repo:String!) {
                repository(owner:$owner, name:$repo) { owner { __typename } }
              }`;
            const d = await github.graphql(q, { owner, repo });
            return d.repository.owner.__typename; // "Organization" or "User"

      - name: Note (Issue Types require org + PAT)
        if: ${{ steps.map.outputs.result != '' && (steps.pat.outputs.has != 'true' || steps.owner.outputs.result != 'Organization') }}
        run: echo "Skipping Issue Type update (PAT missing or owner is not an Organization)."

      - name: Set Issue Type (GraphQL via PAT)
        if: ${{ steps.map.outputs.result != '' && steps.pat.outputs.has == 'true' && steps.owner.outputs.result == 'Organization' }}
        uses: actions/github-script@v7
        env:
          TYPE_NAME: ${{ steps.map.outputs.result }}
          ISSUE_NUMBER: ${{ needs.prepare.outputs.issue_number }}
        with:
          github-token: ${{ secrets.ORG_GRAPHQL_TOKEN }}
          script: |
            const { owner, repo } = context.repo;
            const typeName = process.env.TYPE_NAME;
            const number = parseInt(process.env.ISSUE_NUMBER, 10);

            // Get Issue node id
            const q1 = `
              query($owner:String!, $repo:String!, $number:Int!) {
                repository(owner:$owner, name:$repo) {
                  issue(number:$number) { id }
                  owner {
                    __typename
                    ... on Organization {
                      issueTypes(first:100) { nodes { id name } }
                    }
                  }
                }
              }`;
            const d1 = await github.graphql(q1, { owner, repo, number });
            const issueId = d1.repository.issue.id;

            const org = d1.repository.owner;
            if (!org || org.__typename !== 'Organization' || !org.issueTypes) {
              throw new Error("Issue Types not enabled or accessible for this org (check PAT scopes + SSO).");
            }
            const match = org.issueTypes.nodes.find(t => t.name.toLowerCase() === typeName.toLowerCase());
            if (!match) throw new Error(`Issue Type "${typeName}" not found. Create it in org settings or adjust mapping.`);

            const mut = `
              mutation($issueId:ID!, $issueTypeId:ID!) {
                updateIssue(input: {id:$issueId, issueTypeId:$issueTypeId}) {
                  issue { id number }
                }
              }`;
            await github.graphql(mut, { issueId, issueTypeId: match.id });
            core.info(`Issue #${number}: type set to "${typeName}".`);

  project_add:
    name: Add to Project board
    runs-on: ubuntu-latest
    needs: [prepare]
    outputs:
      item_id: ${{ steps.add_item.outputs.item_id }}

    steps:
      - name: Skip (no project board name set)
        if: ${{ env.PROJECT_BOARD_NAME == '' }}
        run: echo "PROJECT_BOARD_NAME not set; skipping project add."
        
      - name: Check PAT availability
        id: pat
        env:
          PAT: ${{ secrets.ORG_GRAPHQL_TOKEN }}
        run: |
          if [ -n "${PAT}" ]; then echo "has=true" >> "$GITHUB_OUTPUT"; else echo "has=false" >> "$GITHUB_OUTPUT"; fi

      - name: Add issue to Project Board
        id: add_item
        if: ${{ env.PROJECT_BOARD_NAME != '' && steps.pat.outputs.has == 'true' }}
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.ORG_GRAPHQL_TOKEN }}
          script: |
            const owner = context.repo.owner;
            const projectTitle = process.env.PROJECT_BOARD_NAME;
            const issueNodeId = "${{ needs.prepare.outputs.issue_node_id }}";
            if (!issueNodeId) { core.setFailed("Missing issue node id."); return; }

            async function findProjectId() {
              try {
                const qOrg = await github.graphql(`
                  query($login:String!, $q:String!) {
                    organization(login:$login) { projectsV2(first: 20, query: $q) { nodes { id title } } }
                  }`, { login: owner, q: projectTitle });
                const p = qOrg?.organization?.projectsV2?.nodes?.find(n => n.title === projectTitle);
                if (p) return p.id;
              } catch {}
              const qUser = await github.graphql(`
                query($login:String!, $q:String!) {
                  user(login:$login) { projectsV2(first: 20, query: $q) { nodes { id title } } }
                }`, { login: owner, q: projectTitle });
              return qUser?.user?.projectsV2?.nodes?.find(n => n.title === projectTitle)?.id || null;
            }

            const projectId = await findProjectId();
            if (!projectId) { core.warning(`Project board "${projectTitle}" not found under ${owner}. Skipping.`); return; }

            const added = await github.graphql(`
              mutation($projectId:ID!, $contentId:ID!) {
                addProjectV2ItemById(input:{ projectId:$projectId, contentId:$contentId }) {item { id }}
              }`, { projectId, contentId: issueNodeId });
            const itemId = added?.addProjectV2ItemById?.item?.id || "";
            core.setOutput('item_id', itemId);
            core.info(`Added to project "${projectTitle}" (itemId=${itemId}).`);

      - name: Note (PAT missing)
        if: ${{ env.PROJECT_BOARD_NAME != '' && steps.pat.outputs.has != 'true' }}
        run: echo "ORG_GRAPHQL_TOKEN not set; cannot modify org Projects v2. Skipping project add."

  project_field_update:
    name: Project fields update
    runs-on: ubuntu-latest
    needs: [prepare, project_add]
    steps:
      - name: Note (no sprint label detected)
        if: ${{ needs.prepare.outputs.sprint_slug == '' }}
        run: echo "No sprint label."

      - name: Check PAT availability
        id: pat
        env:
          PAT: ${{ secrets.ORG_GRAPHQL_TOKEN }}
        run: |
          if [ -n "${PAT}" ]; then echo "has=true" >> "$GITHUB_OUTPUT"; else echo "has=false" >> "$GITHUB_OUTPUT"; fi

      - name: Update Project fields
        if: ${{ steps.pat.outputs.has == 'true' }}
        uses: actions/github-script@v7
        env:
          ITEM_ID_FROM_ADD: ${{ needs.project_add.outputs.item_id }}
        with:
          github-token: ${{ secrets.ORG_GRAPHQL_TOKEN }}
          script: |
            const owner = context.repo.owner;
            const projectTitle = process.env.PROJECT_BOARD_NAME;
            const sprintFieldName = process.env.PROJECT_SPRINT_FIELD_NAME;
            const priorityFieldName = process.env.PROJECT_PRIORITY_FIELD_NAME || '';
            const targetDateFieldName = process.env.PROJECT_TARGET_DATE_FIELD_NAME || '';
            const defaultPriority = process.env.DEFAULT_PRIORITY || 'Low';
            const offsetDays = parseInt(process.env.TARGET_DATE_OFFSET_DAYS || '7', 10);

            const issueNodeId = "${{ needs.prepare.outputs.issue_node_id }}";
            const sprintDisplay = "${{ needs.prepare.outputs.sprint_slug }}"; // "Sprint N"
            const justAdded = !!process.env.ITEM_ID_FROM_ADD;

            const norm = s => String(s||'').toLowerCase().replace(/[^a-z0-9]/g,'');
            const targetKey = sprintDisplay ? norm(sprintDisplay) : '';

            function plusDaysUTC(days) {
              const d = new Date();
              d.setUTCHours(0,0,0,0);
              d.setUTCDate(d.getUTCDate() + days);
              return d.toISOString().slice(0,10); // YYYY-MM-DD
            }
            const defaultTargetDate = plusDaysUTC(offsetDays);

            async function findProjectId() {
              try {
                const qOrg = await github.graphql(`
                  query($login:String!, $q:String!) {
                    organization(login:$login) { projectsV2(first: 20, query: $q) { nodes { id title } } }
                  }`, { login: owner, q: projectTitle });
                const p = qOrg?.organization?.projectsV2?.nodes?.find(n => n.title === projectTitle);
                if (p) return p.id;
              } catch {}
              const qUser = await github.graphql(`
                query($login:String!, $q:String!) {
                  user(login:$login) { projectsV2(first: 20, query: $q) { nodes { id title } } }
                }`, { login: owner, q: projectTitle });
              return qUser?.user?.projectsV2?.nodes?.find(n => n.title === projectTitle)?.id || null;
            }

            const projectId = await findProjectId();
            if (!projectId) { core.warning(`Project "${projectTitle}" not found.`); return; }

            // Prefer the item id from add step; otherwise try to find it (with a couple retries)
            let itemId = process.env.ITEM_ID_FROM_ADD || '';
            for (let attempt = 1; attempt <= 3 && !itemId; attempt++) {
              const items = await github.graphql(`
                query($projectId:ID!, $after:String) {
                  node(id:$projectId) { ... on ProjectV2 {
                    items(first: 100, after: $after) {
                      nodes { id content { ... on Issue { id number } } }
                      pageInfo { hasNextPage endCursor }
                    }
                  }}}`, { projectId });
              let page = items?.node?.items;
              while (page) {
                const hit = page.nodes?.find(n => n?.content?.id === issueNodeId);
                if (hit?.id) { itemId = hit.id; break; }
                if (page.pageInfo?.hasNextPage) {
                  const more = await github.graphql(`
                    query($projectId:ID!, $after:String) {
                      node(id:$projectId) { ... on ProjectV2 {
                        items(first: 100, after: $after) {
                          nodes { id content { ... on Issue { id number } } }
                          pageInfo { hasNextPage endCursor }
                        }
                      }}}`, { projectId, after: page.pageInfo.endCursor });
                  page = more?.node?.items;
                } else break;
              }
              if (!itemId) { await new Promise(r => setTimeout(r, 1500)); }
            }
            if (!itemId) { core.warning('Project item not found for this issue.'); return; }

            // Fetch fields
            const fields = await github.graphql(`
              query($projectId:ID!) {
                node(id:$projectId) { ... on ProjectV2 {
                  fields(first: 50) {
                    nodes {
                      ... on ProjectV2FieldCommon { id name dataType }
                      ... on ProjectV2SingleSelectField { id name dataType options { id name } }
                      ... on ProjectV2IterationField { id name dataType configuration { iterations { id title } } }
                    }
                  }
                }}
              }`, { projectId });

            const all = fields?.node?.fields?.nodes || [];
            const fieldByName = (n) => all.find(f => (f?.name||'') === n);

            const sprintField = sprintFieldName ? fieldByName(sprintFieldName) : null;
            const priorityField = priorityFieldName ? fieldByName(priorityFieldName) : null;
            const targetDateField = targetDateFieldName ? fieldByName(targetDateFieldName) : null;

            async function updateField(field, value) {
              await github.graphql(`
                mutation($projectId:ID!, $itemId:ID!, $fieldId:ID!, $value:ProjectV2FieldValue!) {
                  updateProjectV2ItemFieldValue(input:{
                    projectId:$projectId, itemId:$itemId, fieldId:$fieldId, value:$value
                  }) { projectV2Item { id } }
                }`, { projectId, itemId, fieldId: field.id, value });
            }

            // --- Set Sprints field from sprint label ---
            if (sprintField && sprintDisplay) {
              let value = null;
              if (sprintField.dataType === 'TEXT') {
                value = { text: sprintDisplay };
              } else if (sprintField.dataType === 'SINGLE_SELECT') {
                const opt = (sprintField.options || []).find(o => {
                  const k = norm(o.name);
                  return k === targetKey || k.startsWith(targetKey); // "sprint12" or "sprint12-…"
                });
                if (!opt) { core.warning(`Single-select option for "${sprintDisplay}" not found.`); }
                else value = { singleSelectOptionId: opt.id };
              } else if (sprintField.dataType === 'ITERATION') {
                const iter = sprintField.configuration?.iterations?.find(i => {
                  const k = norm(i.title);
                  return k === targetKey || k.startsWith(targetKey);
                });
                if (!iter) { core.warning(`Iteration "${sprintDisplay}" not found.`); }
                else value = { iterationId: iter.id };
              } else {
                core.warning(`Unsupported Sprint field type: ${sprintField.dataType}`);
              }
              if (value) { await updateField(sprintField, value); core.info(`Set "${sprintFieldName}" → ${sprintDisplay}`); }
            }

            // --- Default Priority (only when just added) ---
            if (justAdded && priorityField && defaultPriority) {
              if (priorityField.dataType === 'SINGLE_SELECT') {
                const opt = (priorityField.options || []).find(o => o.name.toLowerCase() === defaultPriority.toLowerCase());
                if (opt) {
                  await updateField(priorityField, { singleSelectOptionId: opt.id });
                  core.info(`Defaulted "${priorityFieldName}" → ${defaultPriority}`);
                } else {
                  core.warning(`Priority option "${defaultPriority}" not found. Skipping default.`);
                }
              } else if (priorityField.dataType === 'TEXT') {
                await updateField(priorityField, { text: defaultPriority });
                core.info(`Defaulted "${priorityFieldName}" (TEXT) → ${defaultPriority}`);
              } else {
                core.warning(`Unsupported Priority field type: ${priorityField.dataType}`);
              }
            } else if (!justAdded) {
              core.info('Skipping Priority default (item existed already).');
            }

            // --- Default Target date (today + offset, only when just added) ---
            if (justAdded && targetDateField) {
              if (targetDateField.dataType === 'DATE') {
                await updateField(targetDateField, { date: defaultTargetDate });
                core.info(`Defaulted "${targetDateFieldName}" → ${defaultTargetDate}`);
              } else if (targetDateField.dataType === 'TEXT') {
                await updateField(targetDateField, { text: defaultTargetDate });
                core.info(`Defaulted "${targetDateFieldName}" (TEXT) → ${defaultTargetDate}`);
              } else {
                core.warning(`Unsupported Target date field type: ${targetDateField.dataType}`);
              }
            } else if (!justAdded) {
              core.info('Skipping Target date default (item existed already).');
            }

      - name: Note (PAT missing)
        if: ${{ steps.pat.outputs.has != 'true' }}
        run: echo "ORG_GRAPHQL_TOKEN not set; cannot update project fields. Skipping."

  sprint_to_milestone:
    name: Sprint → Milestone
    runs-on: ubuntu-latest
    needs: [prepare]
    if: ${{ needs.prepare.outputs.sprint_slug != '' }}
    steps:
      - name: "Ensure milestone exists and assign (robust match: \"Sprint # - …\")"
        uses: actions/github-script@v7
        env:
          SPRINT_DISPLAY: ${{ needs.prepare.outputs.sprint_slug }}
          ISSUE_NUMBER: ${{ needs.prepare.outputs.issue_number }}
        with:
          script: |
            const sprintDisplay = process.env.SPRINT_DISPLAY || '';   // "Sprint 12"
            const issueNumber   = parseInt(process.env.ISSUE_NUMBER, 10);

            // Extract the sprint number (12)
            const num = (sprintDisplay.match(/(\d+)/) || [])[1];
            if (!num) {
              core.warning(`Could not extract sprint number from "${sprintDisplay}".`);
              return;
            }

            // Build a tolerant matcher:
            // ^Sprint\s*#?\s*12(\b|space|dash)   → matches "Sprint 12", "Sprint #12", "Sprint 12 - Foo"
            const re = new RegExp(`^\\s*sprint\\s*#?\\s*${num}(\\b|\\s|[-–—])`, 'i');

            // Search ALL milestones so we can match closed ones too
            const all = await github.paginate(
              github.rest.issues.listMilestones,
              { ...context.repo, state: 'all', per_page: 100 }
            );

            const matches = all.filter(m => re.test(m.title || ''));

            // Prefer OPEN > then best CLOSED
            let chosen = null;
            const open = matches.filter(m => m.state !== 'closed');
            if (open.length) {
              // Among open, prefer earliest due date (if present)
              open.sort((a,b) => (a.due_on || '9999').localeCompare(b.due_on || '9999'));
              chosen = open[0];
            } else if (matches.length) {
              const closed = matches
                .filter(m => m.state === 'closed')
                .sort((a,b) => (b.closed_at || '').localeCompare(a.closed_at || ''));
              chosen = closed[0];
            }

            // If none matched, create a minimal "Sprint N"
            if (!chosen) {
              const { data: created } = await github.rest.issues.createMilestone({
                ...context.repo,
                title: sprintDisplay
              });
              chosen = created;
              core.info(`Created milestone: ${created.title}`);
            } else {
              core.info(`Matched milestone: ${chosen.title} (state=${chosen.state})`);
            }

            // Assign the milestone
            await github.rest.issues.update({
              ...context.repo,
              issue_number: issueNumber,
              milestone: chosen.number
            });
            core.info(`Assigned milestone "${chosen.title}" to issue #${issueNumber}.`);
