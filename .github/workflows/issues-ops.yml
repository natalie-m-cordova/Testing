name: Issue Ops (Project â€¢ Owner â€¢ Labels â€¢ Sprintâ†’Field/Milestone)

on:
  issues:
    types: [opened, edited, labeled, reopened]
  workflow_dispatch:
    inputs:
      number:
        description: "Issue number to reprocess (optional)"
        required: false
        type: number

env:
  PROJECT_BOARD_NAME: "Testing Project Board"
  PROJECT_SPRINT_FIELD_NAME: "Sprint"
  DEFAULT_ASSIGNEES: "NMRCDova"
  TYPE_LABEL_MAP_JSON: >-
    {
      "epic": "type: Epic",
      "bug": "type: Bug",
      "enhancement": "type: Enhancement",
      "documentation": "type: Documentation",
      "duplicate": "type: Duplicate"
    }

permissions:
  contents: read
  issues: write

concurrency:
  group: ${{ github.workflow }}-${{ github.event.issue.number || inputs.number || github.run_id }}
  cancel-in-progress: false

jobs:
  prepare:
    name: Prepare context
    runs-on: ubuntu-latest
    outputs:
      issue_number: ${{ steps.ctx.outputs.issue_number }}
      issue_node_id: ${{ steps.ctx.outputs.issue_node_id }}
      labels_json: ${{ steps.ctx.outputs.labels_json }}
      sprint_label: ${{ steps.ctx.outputs.sprint_label }}
      sprint_slug: ${{ steps.ctx.outputs.sprint_slug }}
    steps:
      - name: Derive context
        id: ctx
        uses: actions/github-script@v7
        env:
          DISPATCH_ISSUE_NUMBER: ${{ inputs.number }}
        with:
          script: |
            const owner = context.repo.owner;
            const repo  = context.repo.repo;

            // prefer dispatch input; else issues event payload
            const inputNumberRaw =
              (process.env.DISPATCH_ISSUE_NUMBER || (context.payload.inputs && context.payload.inputs.number) || '').trim();

            let issue = null;
            if (inputNumberRaw) {
              const n = Number(inputNumberRaw);
              if (Number.isFinite(n) && n > 0) {
                try {
                  issue = (await github.rest.issues.get({ owner, repo, issue_number: n })).data;
                } catch (e) {
                  core.setFailed(`Could not load issue #${n}: ${e.message}`);
                  core.setOutput('issue_number', '');
                  core.setOutput('issue_node_id', '');
                  core.setOutput('labels_json', '[]');
                  core.setOutput('sprint_label', '');
                  core.setOutput('sprint_slug', '');
                  return;
                }
              }
            } else if (context.payload && context.payload.issue) {
              issue = context.payload.issue;
            }

            if (!issue) {
              core.setFailed("No issue context found (on workflow_dispatch, pass 'number').");
              core.setOutput('issue_number', '');
              core.setOutput('issue_node_id', '');
              core.setOutput('labels_json', '[]');
              core.setOutput('sprint_label', '');
              core.setOutput('sprint_slug', '');
              return;
            }

            const labels = (issue.labels || []).map(l => typeof l === 'string' ? l : (l.name || '')).filter(Boolean);
            const sprint = labels.find(l => /^sprint\s*\d+$/i.test(l)) || '';

            const data = await github.graphql(
              `query($owner:String!,$repo:String!,$number:Int!){
                 repository(owner:$owner, name:$repo){ issue(number:$number){ id number } }
               }`,
              { owner, repo, number: issue.number }
            );
            const nodeId = data?.repository?.issue?.id || '';

            core.setOutput('issue_number', String(issue.number));
            core.setOutput('issue_node_id', nodeId);
            core.setOutput('labels_json', JSON.stringify(labels));
            core.setOutput('sprint_label', sprint);
            core.setOutput('sprint_slug', sprint.replace(/\s+/g,' ').trim());

      - name: Log context
        if: ${{ steps.ctx.outputs.issue_number != '' }}
        run: |
          echo "issue_number=${{ steps.ctx.outputs.issue_number }}"
          echo "sprint_label=${{ steps.ctx.outputs.sprint_label }}"
          echo "labels=${{ steps.ctx.outputs.labels_json }}"

  assign_and_normalize:
    name: Assign owner & set Issue Type (keep original labels)
    runs-on: ubuntu-latest
    needs: [prepare]
    steps:
      - name: Assign default owners (if configured)
        if: ${{ env.DEFAULT_ASSIGNEES != '' }}
        uses: actions/github-script@v7
        with:
          script: |
            const list = (process.env.DEFAULT_ASSIGNEES || '').split(',').map(s=>s.trim()).filter(Boolean);
            if (!list.length) { core.info('No default assignees configured.'); return; }
            await github.rest.issues.addAssignees({
              ...context.repo,
              issue_number: Number("${{ needs.prepare.outputs.issue_number }}"),
              assignees: list
            });
            core.info(`Assigned: ${list.join(', ')}`);

      - name: Map label -> Issue Type name
        id: map
        uses: actions/github-script@v7
        env:
          LABELS_JSON: ${{ needs.prepare.outputs.labels_json }}
          TYPE_LABEL_MAP_JSON: ${{ env.TYPE_LABEL_MAP_JSON }}
        with:
          result-encoding: string
          script: |
            const labels = JSON.parse(process.env.LABELS_JSON || '[]').map(l => String(l||'').toLowerCase());
            const map = JSON.parse(process.env.TYPE_LABEL_MAP_JSON || '{}');
            // map example: {"bug":"type: Bug", "enhancement":"type: Enhancement", ...}
            let typeName = '';
            for (const [raw, canonical] of Object.entries(map)) {
              if (labels.includes(String(raw).toLowerCase())) {
                typeName = String(canonical).replace(/^type:\s*/i, '').trim(); // "type: Bug" -> "Bug"
                break;
              }
            }
            return typeName; // empty string if no match

      - name: Note (no matching type from labels)
        if: ${{ steps.map.outputs.result == '' }}
        run: echo "No mapped Issue Type from labels. Skipping type update."

      - name: Check PAT availability
        id: pat
        env:
          PAT: ${{ secrets.ORG_GRAPHQL_TOKEN }}
        run: |
          if [ -n "${PAT}" ]; then echo "has=true" >> "$GITHUB_OUTPUT"; else echo "has=false" >> "$GITHUB_OUTPUT"; fi

      - name: Inspect owner type (User vs Organization)
        id: owner
        if: ${{ steps.map.outputs.result != '' && steps.pat.outputs.has == 'true' }}
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.ORG_GRAPHQL_TOKEN }}
          result-encoding: string
          script: |
            const { owner, repo } = context.repo;
            const q = `
              query($owner:String!, $repo:String!) {
                repository(owner:$owner, name:$repo) { owner { __typename } }
              }`;
            const d = await github.graphql(q, { owner, repo });
            return d.repository.owner.__typename; // "Organization" or "User"

      - name: Note (Issue Types require org + PAT)
        if: ${{ steps.map.outputs.result != '' && (steps.pat.outputs.has != 'true' || steps.owner.outputs.result != 'Organization') }}
        run: echo "Skipping Issue Type update (PAT missing or owner is not an Organization)."

      - name: Set Issue Type (GraphQL via PAT)
        if: ${{ steps.map.outputs.result != '' && steps.pat.outputs.has == 'true' && steps.owner.outputs.result == 'Organization' }}
        uses: actions/github-script@v7
        env:
          TYPE_NAME: ${{ steps.map.outputs.result }}
          ISSUE_NUMBER: ${{ needs.prepare.outputs.issue_number }}
        with:
          github-token: ${{ secrets.ORG_GRAPHQL_TOKEN }}
          script: |
            const { owner, repo } = context.repo;
            const typeName = process.env.TYPE_NAME;
            const number = parseInt(process.env.ISSUE_NUMBER, 10);

            // Get Issue node id
            const q1 = `
              query($owner:String!, $repo:String!, $number:Int!) {
                repository(owner:$owner, name:$repo) {
                  issue(number:$number) { id }
                  owner {
                    __typename
                    ... on Organization {
                      issueTypes(first:100) { nodes { id name } }
                    }
                  }
                }
              }`;
            const d1 = await github.graphql(q1, { owner, repo, number });
            const issueId = d1.repository.issue.id;

            const org = d1.repository.owner;
            if (!org || org.__typename !== 'Organization' || !org.issueTypes) {
              throw new Error("Issue Types not enabled or accessible for this org (check PAT scopes + SSO).");
            }
            const match = org.issueTypes.nodes.find(t => t.name.toLowerCase() === typeName.toLowerCase());
            if (!match) throw new Error(`Issue Type "${typeName}" not found. Create it in org settings or adjust mapping.`);

            const mut = `
              mutation($issueId:ID!, $issueTypeId:ID!) {
                updateIssue(input: {id:$issueId, issueTypeId:$issueTypeId}) {
                  issue { id number }
                }
              }`;
            await github.graphql(mut, { issueId, issueTypeId: match.id });
            core.info(`Issue #${number}: type set to "${typeName}".`);

  project_add:
    name: Add to Project board
    runs-on: ubuntu-latest
    needs: [prepare, assign_and_normalize]
    steps:
      - name: Skip (no project board name set)
        if: ${{ env.PROJECT_BOARD_NAME == '' }}
        run: echo "PROJECT_BOARD_NAME not set; skipping project add."

      # ðŸ‘‡ turn the secret into a step output we can branch on
      - name: Check PAT availability
        id: pat
        env:
          PAT: ${{ secrets.ORG_GRAPHQL_TOKEN }}
        run: |
          if [ -n "${PAT}" ]; then echo "has=true" >> "$GITHUB_OUTPUT"; else echo "has=false" >> "$GITHUB_OUTPUT"; fi

      - name: Add issue to Project (Projects v2)
        if: ${{ env.PROJECT_BOARD_NAME != '' && steps.pat.outputs.has == 'true' }}
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.ORG_GRAPHQL_TOKEN }}
          script: |
            const owner = context.repo.owner;
            const projectTitle = process.env.PROJECT_BOARD_NAME;
            const issueNodeId = "${{ needs.prepare.outputs.issue_node_id }}";
            if (!issueNodeId) { core.setFailed("Missing issue node id."); return; }

            let projectId = null;
            try {
              const qOrg = await github.graphql(`
                query($login:String!,$q:String!) {
                  organization(login:$login) {
                    projectsV2(first: 20, query: $q) { nodes { id title } }
                  }
                }`, { login: owner, q: projectTitle }
              );
              projectId = qOrg?.organization?.projectsV2?.nodes?.find(n => n.title === projectTitle)?.id || null;
            } catch {}
            if (!projectId) {
              try {
                const qUser = await github.graphql(`
                  query($login:String!,$q:String!) {
                    user(login:$login) {
                      projectsV2(first: 20, query: $q) { nodes { id title } }
                    }
                  }`, { login: owner, q: projectTitle }
                );
                projectId = qUser?.user?.projectsV2?.nodes?.find(n => n.title === projectTitle)?.id || null;
              } catch {}
            }
            if (!projectId) { core.warning(`Project board "${projectTitle}" not found under ${owner}. Skipping.`); return; }

            const added = await github.graphql(`
              mutation($projectId:ID!, $contentId:ID!) {
                addProjectV2ItemById(input:{ projectId:$projectId, contentId:$contentId }) {
                  item { id }
                }
              }`,
              { projectId, contentId: issueNodeId }
            );
            const itemId = added?.addProjectV2ItemById?.item?.id || "";
            core.info(`Added issue to project "${projectTitle}" (itemId=${itemId}).`);

      - name: Note (PAT missing)
        if: ${{ env.PROJECT_BOARD_NAME != '' && steps.pat.outputs.has != 'true' }}
        run: echo "ORG_GRAPHQL_TOKEN not set; cannot modify org Projects v2. Skipping project add."

  sprint_to_project_field:
    name: Sprint â†’ Project field
    runs-on: ubuntu-latest
    needs: [prepare, project_add]
    steps:
      - name: Skip (no sprint slug or field name)
        if: ${{ needs.prepare.outputs.sprint_slug == '' || env.PROJECT_SPRINT_FIELD_NAME == '' }}
        run: echo "No sprint slug or field name; skipping project field update."

      - name: Check PAT availability
        id: pat
        env:
          PAT: ${{ secrets.ORG_GRAPHQL_TOKEN }}
        run: |
          if [ -n "${PAT}" ]; then echo "has=true" >> "$GITHUB_OUTPUT"; else echo "has=false" >> "$GITHUB_OUTPUT"; fi

      - name: Update Project field (uses PAT)
        if: ${{ needs.prepare.outputs.sprint_slug != '' && env.PROJECT_SPRINT_FIELD_NAME != '' && steps.pat.outputs.has == 'true' }}
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.ORG_GRAPHQL_TOKEN }}
          script: |
            const owner = context.repo.owner;
            const projectTitle = process.env.PROJECT_BOARD_NAME;
            const fieldName = process.env.PROJECT_SPRINT_FIELD_NAME;
            const issueNodeId = "${{ needs.prepare.outputs.issue_node_id }}";
            const sprintValue = "${{ needs.prepare.outputs.sprint_slug }}";

            async function findProjectId() {
              try {
                const qOrg = await github.graphql(`
                  query($login:String!,$q:String!) {
                    organization(login:$login) {
                      projectsV2(first: 20, query: $q) { nodes { id title } }
                    }
                  }`, { login: owner, q: projectTitle }
                );
                const n = qOrg?.organization?.projectsV2?.nodes?.find(n => n.title === projectTitle);
                if (n) return n.id;
              } catch {}
              const qUser = await github.graphql(`
                query($login:String!,$q:String!) {
                  user(login:$login) {
                    projectsV2(first: 20, query: $q) { nodes { id title } }
                  }
                }`, { login: owner, q: projectTitle }
              );
              const m = qUser?.user?.projectsV2?.nodes?.find(n => n.title === projectTitle);
              return m?.id || null;
            }

            const projectId = await findProjectId();
            if (!projectId) { core.warning(`Project "${projectTitle}" not found.`); return; }

            const items = await github.graphql(`
              query($projectId:ID!) {
                node(id:$projectId) {
                  ... on ProjectV2 {
                    items(first: 50) {
                      nodes { id content { ... on Issue { id number } } }
                    }
                  }
                }
              }`, { projectId }
            );
            const item = items?.node?.items?.nodes?.find(n => n?.content?.id === issueNodeId);
            if (!item?.id) { core.warning("Project item not found for this issue."); return; }
            const itemId = item.id;

            const fields = await github.graphql(`
              query($projectId:ID!) {
                node(id:$projectId) {
                  ... on ProjectV2 {
                    fields(first: 50) {
                      nodes {
                        ... on ProjectV2FieldCommon { id name dataType }
                        ... on ProjectV2SingleSelectField { id name dataType options { id name } }
                        ... on ProjectV2IterationField { id name dataType configuration { iterations { id title } } }
                      }
                    }
                  }
                }
              }`, { projectId }
            );
            const f = fields?.node?.fields?.nodes?.find(x => (x?.name||"") === fieldName);
            if (!f?.id) { core.warning(`Field "${fieldName}" not found.`); return; }

            let value = null;
            if (f.dataType === 'TEXT') {
              value = { text: sprintValue };
            } else if (f.dataType === 'SINGLE_SELECT') {
              const opt = (f.options || []).find(o => o.name === sprintValue);
              if (!opt) { core.warning(`Single-select option "${sprintValue}" not found.`); return; }
              value = { singleSelectOptionId: opt.id };
            } else if (f.dataType === 'ITERATION') {
              const iter = f.configuration?.iterations?.find(i => i.title === sprintValue);
              if (!iter) { core.warning(`Iteration "${sprintValue}" not found.`); return; }
              value = { iterationId: iter.id };
            } else {
              core.warning(`Unsupported field dataType: ${f.dataType}`);
              return;
            }

            await github.graphql(`
              mutation($projectId:ID!,$itemId:ID!,$fieldId:ID!,$value:ProjectV2FieldValue!) {
                updateProjectV2ItemFieldValue(input:{
                  projectId:$projectId, itemId:$itemId, fieldId:$fieldId, value:$value
                }) { projectV2Item { id } }
              }`, { projectId, itemId, fieldId: f.id, value }
            );
            core.info(`Updated project field "${fieldName}" to "${sprintValue}".`)
      - name: Note (PAT missing)
        if: ${{ needs.prepare.outputs.sprint_slug != '' && env.PROJECT_SPRINT_FIELD_NAME != '' && steps.pat.outputs.has != 'true' }}
        run: echo "ORG_GRAPHQL_TOKEN not set; cannot update org Projects v2 field. Skipping."

  sprint_to_milestone:
    name: Sprint â†’ Milestone
    runs-on: ubuntu-latest
    needs: [prepare, sprint_to_project_field]
    if: ${{ needs.prepare.outputs.sprint_slug != '' }}
    steps:
      - name: Ensure milestone exists and assign
        uses: actions/github-script@v7
        with:
          script: |
            const title = "${{ needs.prepare.outputs.sprint_slug }}";
            const { data: milestones } = await github.rest.issues.listMilestones({
              ...context.repo, state: 'open'
            });
            let ms = milestones.find(m => m.title.toLowerCase() === title.toLowerCase());
            if (!ms) {
              ms = (await github.rest.issues.createMilestone({ ...context.repo, title })).data;
              core.info(`Created milestone: ${ms.title}`);
            }
            await github.rest.issues.update({
              ...context.repo,
              issue_number: Number("${{ needs.prepare.outputs.issue_number }}"),
              milestone: ms.number
            });
            core.info(`Assigned milestone "${ms.title}".`)
